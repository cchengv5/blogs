<!DOCTYPE html>
<html>

<head>
    <title>概念地图</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        #container {
            display: flex;
            height: 100vh;
            position: relative;
            overflow: hidden;
            /* 添加这行防止内容溢出 */
        }

        #input {
            width: 400px;
            min-width: 400px;
            height: 100vh;
            /* 改为100vh高度 */
            padding: 10px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }

        #textArea {
            width: 100%;
            height: calc(100vh - 60px);
            /* 减去按钮和padding的高度 */
            margin-bottom: 15px;
            padding: 12px;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid #ced4da;
            border-radius: 6px;
            resize: vertical;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        #physics-panel {
            width: 300px;
            padding: 15px;
            background: #f8f9fa;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }

        .physics-section {
            margin-bottom: 20px;
            padding: 10px;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
        }
        .physics-section button {
            padding: 5px 10px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
        }
        .physics-section button:hover {
            background: #e0e0e0;
        }
        
        /* 添加菜单样式 */
        .menu {
            position: relative;
            display: inline-block;
        }
        .menu-btn {
            padding: 8px 16px;
            background-color: #f1f1f1;
            border: none;
            cursor: pointer;
        }
        .menu-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }
        .menu-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        .menu-content a:hover {
            background-color: #ddd;
        }
        .menu:hover .menu-content {
            display: block;
        }
        .menu:hover .menu-btn {
            background-color: #ddd;
        }
        .splitter {
            width: 5px;
            background: #ddd;
            cursor: col-resize;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 400px;
            z-index: 10;
            user-select: none;
            /* 防止拖拽时选中文本 */
        }
    </style>
</head>

<body>
    <div id="menu-bar">
        <div class="menu">
            <button class="menu-btn">File</button>
            <div class="menu-content">
                <a href="#" onclick="loadFromFile()">从文件加载</a>
                <a href="#" onclick="saveToFile()">保存到文件</a>
                <a href="#" onclick="saveAsFile()">另存为...</a>
            </div>
        </div>
    </div>
    <div id="container">
        <div id="input">
            <textarea id="textArea" placeholder="输入关系，每行一个"></textarea>
            <button onclick="updateGraph()">更新图形</button>
        </div>
        <div id="network"></div>
        <div id="physics-panel">
            <div class="physics-section">
                <h3>核心物理引擎设置</h3>
                <div class="control-item">
                    <label>启用物理模拟: <input type="checkbox" id="physicsEnabled" checked></label>
                </div>
                <div class="control-item">
                    <label>求解器类型:
                        <select id="physicsSolver">
                            <option value="barnesHut">Barnes-Hut</option>
                            <option value="repulsion">Repulsion</option>
                            <option value="forceAtlas2Based">ForceAtlas2</option>
                        </select>
                    </label>
                </div>
                <!-- 其他核心参数控件... -->
            </div>
            <div class="physics-section" id="barnesHutParams">
                <h3>Barnes-Hut参数</h3>
                <div class="control-item">
                    <label>引力常数: <input type="range" id="bhGravitationalConstant" min="-5000" max="5000"
                            value="-2000"></label>
                    <span id="bhGravitationalConstantValue">-2000</span>
                </div>
                <!-- 其他Barnes-Hut参数控件... -->
            </div>
            <button onclick="applyPhysicsSettings()">应用物理设置</button>
        </div>
    </div>

    <script>
        var myNodes = new Map(); // 存储节点的Map，key为节点ID，value为节点对象
        var myEdges = new Map(); // 存储边的Map，key为边的ID，value为边对象
        let currentFilePath = null;

        let visNetwork;


        // 在脚本开始部分添加边样式配置对象
        const edgeStyles = {
            default: {
                arrows: {
                    to: {
                        enabled: true,
                        scaleFactor: 1.5,
                        type: 'arrow' // 明确指定箭头类型
                    }
                },
                font: {
                    align: 'middle'
                },
                smooth: {
                    type: 'continuous'
                }
            },
            superInEdge: {
                arrows: {
                    to: {
                        enabled: false,
                        scaleFactor: 1.5
                    }
                }
            },
            superOutEdge: {
                arrows: {
                    to: {
                        enabled: true,
                        scaleFactor: 1.5
                    }
                }
            },
            superOutEdgeReverse: {
                arrows: {
                    to: {
                        enabled: false,
                        scaleFactor: 1.5
                    }
                }
            }
        };

        // 添加节点，包括超级边节点
        // 修改nodeStyles配置
        const nodeStyles = {
            default: {
                shape: 'box',
                color: {
                    background: 'white',
                    border: '#2B7CE9'
                },
                margin: 10,
                font: {
                    size: 14
                },
                color: {
                    background: 'white',
                    border: '#2B7CE9'
                },
                shadow: {
                    enabled: true,
                },
                widthConstraint: {
                    maximum: 200  // 设置最大宽度
                },
                heightConstraint: {
                    minimum: 30,  // 最小高度
                    valign: 'middle'  // 垂直居中
                }
            },
            superEdge: {
                font: {
                    italic: true
                },
                borderWidth: 0,
                color: {
                    background: '#FFE4E1',
                },
                shadow: {
                    enabled: true,
                }
            }
        };

        // 节点
        class MyNode {
            relationIn = new Map(); // 入边
            relationOut = new Map(); // 出边

            constructor(id, label) {
                this.id = id;
                this.label = label;
            }

            addInputReason(myEdge) {
                if (this.relationIn.has(myEdge.reason)) {
                    this.relationIn.get(myEdge.reason).add(myEdge);
                    return;
                }
                this.relationIn.set(myEdge.reason, new Set([myEdge]));
            }

            addOutputEdges(myEdge) {
                if (this.relationOut.has(myEdge.reason)) {
                    this.relationOut.get(myEdge.reason).add(myEdge);
                    return;
                }
                this.relationOut.set(myEdge.reason, new Set([myEdge]));
            }

            isSuperOutEdge(myEdge) {
                let xx = this.relationOut.get(myEdge.reason);
                if (xx && xx.size > 1) {
                    return true;
                }
                return false;
            }

            isSuperInEdge(myEdge) {
                let xx = this.relationIn.get(myEdge.reason);
                if (xx && xx.size > 1) {
                    return true;
                }
                return false;
            }
        }

        // 边
        class MyEdge {
            constructor(from, to, reason, isArrow = false) {
                this.from = from;
                this.to = to;
                this.reason = reason;
                this.isArrow = isArrow; // 是否有箭头
                this.id = `${from}-${reason}-${to}`;
            }

            getSuperInEdgeNodeName() {
                return this.reason + "_" + this.to;
            }

            getSuperOutEdgeNodeName() {
                return this.from + "_" + this.reason;
            }

            getSuperInEdgeNode() {
                return new MyNode(this.getSuperInEdgeNodeName(), this.reason);
            }

            getSuperOutEdgeNode() {
                return new MyNode(this.getSuperOutEdgeNodeName(), this.reason);
            }

            getToSuperInEdges() {
                return [new MyEdge(this.from, this.getSuperInEdgeNodeName(), this.reason, this.isArrow),
                new MyEdge(this.getSuperInEdgeNodeName(), this.to, this.reason, this.isArrow)
                ]
            }

            getSuperOutEdges() {
                return [new MyEdge(this.getSuperOutEdgeNodeName(), this.to, this.reason, this.isArrow),
                new MyEdge(this.from, this.getSuperOutEdgeNodeName(), this.reason, this.isArrow)]
            }

            isSuperInEdge() {
                if (myNodes.get(this.to)?.isSuperInEdge(this) && this.reason != '') {
                    return true;
                }
                return false
            }

            isSuperOutEdge() {
                if (myNodes.get(this.from)?.isSuperOutEdge(this) && this.reason != '') {
                    return true;
                }
            }
        }


        // 添加节点
        function addNode(id, label) {
            if (!myNodes.has(id)) {
                myNodes.set(id, new MyNode(id, label));
            }
            return myNodes.get(id);
        }

        // 添加边
        function addEdge(from, to, reason, isArrow = false) {
            const edgeId = `${from}-${reason}-${to}`;
            if (!myEdges.has(edgeId)) {
                const edge = new MyEdge(from, to, reason, isArrow);
                myEdges.set(edgeId, edge);
            }
            myNodes.get(from).addOutputEdges(myEdges.get(edgeId));
            myNodes.get(to).addInputReason(myEdges.get(edgeId))
            return myEdges.get(edgeId);
        }

        function parseRelation(line) {
            line = line.trim();
            if (!line) return null;

            // 解析关系格式：fromNode(-{1,100})(>?)toNode
            const regexWithNames = /^(?<fromNode>.+?)(-+)(?:(?<reason>.+?)(-+))?(?<isArrow>>?)(?<toNode>.*)$/;
            const matchResultWithNames = line.match(regexWithNames);

            var retData = null
            if (!matchResultWithNames) {
                // 孤立节点
                retData = {
                    from: line,
                    to: '',
                    isArrow: false
                };
            } else {
                if (matchResultWithNames && matchResultWithNames.groups) {
                    retData = {
                        from: matchResultWithNames.groups.fromNode.trim(),
                        to: matchResultWithNames.groups.toNode?.trim() || '',
                        reason: matchResultWithNames.groups.reason?.trim() || '',
                        isArrow: matchResultWithNames.groups.isArrow === '>' ? true : false
                    };
                }
            }

            console.log("parseRelation retData=", retData)
            return retData; // 返回解析后的关系对象，或者 null 表示解析失败或不匹配的 forma
        }

        // 保存数据到localStorage
        function saveToStorage(data) {
            localStorage.setItem('conceptMapData', data);
        }

        // 从localStorage加载数据
        function loadFromStorage() {
            return localStorage.getItem('conceptMapData') || '';
        }

        function applyPhysicsSettings() {
            if (!visNetwork) return;

            const settings = {
                enabled: document.getElementById('physicsEnabled').checked,
                solver: document.getElementById('physicsSolver').value,
                barnesHut: {
                    gravitationalConstant: parseInt(document.getElementById('bhGravitationalConstant').value),
                    // 其他Barnes-Hut参数...
                },
                // 其他求解器参数...
            };

            visNetwork.setOptions({ physics: settings });
        }

        function updateGraph() {
            myNodes.clear(); // 清空节点
            myEdges.clear(); // 清空边

            const text = document.getElementById('textArea').value;
            // 保存当前输入
            saveToStorage(text);
            const lines = text.split('\n').filter(line => line.trim());

            // 节点
            const nodeMap = new Map();
            // 边
            const edgeGroups = new Map();

            // 解析每行关系
            lines.forEach(line => {
                const relation = parseRelation(line);
                if (!relation) return;

                // 初始化节点和边
                addNode(relation.from, relation.from); // 添加from节点
                if (relation.to) addNode(relation.to, relation.to); // 添加to节点
                if (relation.to) addEdge(relation.from, relation.to, relation.reason || '', relation.isArrow); // 添加边
            });


            const nodes = new vis.DataSet();
            const edges = new vis.DataSet();

            // 修改节点添加逻辑
            myNodes.forEach(myNode => {
                if (nodes.get(myNode.id) == null) {
                    nodes.add({
                        id: myNode.id,
                        label: myNode.label,
                        ...nodeStyles.default
                    });
                }
            });

            // 添加边
            myEdges.forEach(myEdge => {
                if (myEdge.isSuperInEdge()) {
                    let xxxnode = myEdge.getSuperInEdgeNode();
                    let [edge0, edge1] = myEdge.getToSuperInEdges();
                    if (nodes.get(xxxnode.id) == undefined) {
                        nodes.add({ id: xxxnode.id, label: xxxnode.label, ...nodeStyles.superEdge });
                    }
                    if (!edges.get(edge0.id)) {
                        edges.add({
                            id: edge0.id,
                            from: edge0.from,
                            to: edge0.to,
                            ...edgeStyles.superInEdge
                        });
                    }
                    if (!edges.get(edge1.id)) {
                        edges.add({
                            id: edge1.id,
                            from: edge1.from,
                            to: edge1.to,
                            ...edgeStyles.default
                        });
                    }
                    return;
                }

                if (myEdge.isSuperOutEdge()) {
                    let xxxnode = myEdge.getSuperOutEdgeNode();
                    let [edge0, edge1] = myEdge.getSuperOutEdges();
                    if (nodes.get(xxxnode.id) == undefined) {
                        nodes.add({
                            id: xxxnode.id,
                            label: xxxnode.label,
                            font: { italic: true },
                            ...nodeStyles.superEdge
                        });
                    }
                    if (!edges.get(edge0.id)) {
                        edges.add({
                            id: edge0.id,
                            from: edge0.from,
                            to: edge0.to,
                            ...edgeStyles.superOutEdge
                        });
                    }
                    if (!edges.get(edge1.id)) {
                        edges.add({
                            id: edge1.id,
                            from: edge1.from,
                            to: edge1.to,
                            ...edgeStyles.superOutEdgeReverse
                        });
                    }
                    return;
                }

                edges.add({
                    id: myEdge.id,
                    from: myEdge.from,
                    to: myEdge.to,
                    label: myEdge.reason,
                    ...edgeStyles.default
                });
            });

            nodes.forEach(node => {
                console.log("node=", node)
            })

            // 创建网络
            const container = document.getElementById('network');
            const data = { nodes, edges };
            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    font: { size: 14 },
                    color: { background: 'white', border: '#2B7CE9' },
                    physics: true, // 禁用节点的物理模拟
                    fixed: false // 固定节点位置
                },
                edges: {
                    smooth: {
                        enabled: true,
                        type: 'continuous',
                        roundness: 0.5
                    },
                    length: 200 // 增加边的默认长度
                },
                physics: {
                    enabled: true,
                    solver: 'repulsion',
                    repulsion: {
                        nodeDistance: 300, // 增加节点间的最小距离
                        centralGravity: 0.1,
                        springLength: 300,
                        springConstant: 0.01,
                        damping: 0.09,
                    },
                    stabilization: {
                        enabled: true,
                        iterations: 1000,
                        updateInterval: 25
                    },
                },
                layout: {
                    hierarchical: {
                        enabled: true,
                        direction: 'LR', // 从上到下的层次布局
                        sortMethod: 'directed', // 有向排序
                        levelSeparation: 200, // 增加层次之间的距离
                        nodeSpacing: 150 // 增加节点之间的距离
                    },
                    randomSeed: 42
                }
            };
            visNetwork = new vis.Network(container, data, options);

            // 保存节点位置
            visNetwork.on('stabilizationIterationsDone', function () {
                const positions = visNetwork.getPositions();
                localStorage.setItem('nodePositions', JSON.stringify(positions));
            });

            // 恢复节点位置
            const savedPositions = localStorage.getItem('nodePositions');
            if (savedPositions) {
                const positions = JSON.parse(savedPositions);
                nodes.forEach(node => {
                    if (positions[node.id]) {
                        node.x = positions[node.id].x;
                        node.y = positions[node.id].y;
                        node.fixed = false; // 固定位置
                    }
                });
                visNetwork.setData({ nodes, edges });
            }
        }

        

        function saveToFile(filename = 'concept-map.txt') {
            const text = document.getElementById('textArea').value;
            const blob = new Blob([text], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }


        function loadFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.onchange = e => {
                const file = e.target.files[0];
                currentFilePath = file.path; // 保存文件路径
                console.log("currentFilePath=", file.path);
                const reader = new FileReader();
                reader.onload = event => {
                    document.getElementById('textArea').value = event.target.result;
                    updateGraph();
                };
                reader.readAsText(file);
            };
            input.click();
        }
    </script>
</body>

</html>

<script>
    // 添加拖拽分隔栏功能
    document.addEventListener('DOMContentLoaded', function () {
        const splitter = document.createElement('div');
        splitter.className = 'splitter';
        document.getElementById('container').appendChild(splitter);

        let isDragging = false;
        splitter.addEventListener('mousedown', function (e) {
            isDragging = true;
            document.body.style.cursor = 'col-resize';
        });

        document.addEventListener('mousemove', function (e) {
            if (!isDragging) return;
            const container = document.getElementById('container');
            const input = document.getElementById('input');
            const newWidth = e.clientX - container.getBoundingClientRect().left;
            input.style.width = newWidth + 'px';
            splitter.style.left = newWidth + 'px';
        });

        document.addEventListener('mouseup', function () {
            isDragging = false;
            document.body.style.cursor = '';
        });
    });

    // 在DOM加载完成后添加加载保存内容的逻辑
    document.addEventListener('DOMContentLoaded', function () {
            const savedData = loadFromStorage();
            if (savedData) {
                document.getElementById('textArea').value = savedData;
            }

            // 添加输入监听器
            const textArea = document.getElementById('textArea');
            let debounceTimer;
            textArea.addEventListener('input', function () {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(updateGraph, 500); // 500ms防抖延迟
            });

            updateGraph();
        });

    // 添加Ctrl+S快捷键监听
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            console.log("Ctrl+S pressed ", currentFilePath);
            if (currentFilePath) {
                const fs = require('fs');
                fs.writeFileSync(currentFilePath, document.getElementById('textArea').value);
                alert('已保存到原始文件: ' + currentFilePath);
            } else {
                saveToFile(); // 如果没有原始文件，则调用普通保存
            }
        }
    });
</script>

